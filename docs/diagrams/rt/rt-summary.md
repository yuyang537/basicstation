# BasicStation 运行时系统 (rt.c) 技术文档

## 系统概述

运行时系统 (rt.c) 是 BasicStation 的核心基础设施，为整个系统提供基础运行时服务。该模块实现了高精度定时器系统、安全内存管理、时间服务、数据解析工具等关键功能，是所有上层模块的基础依赖。

## 核心功能模块

### 1. 定时器系统

#### 1.1 设计架构
- **优先级队列**: 使用链表实现的按截止时间排序的定时器队列
- **单调时钟**: 基于系统单调时钟，不受系统时间调整影响
- **微秒精度**: 支持微秒级的高精度定时
- **回调机制**: 异步回调执行，支持事件驱动编程

#### 1.2 核心数据结构
```c
typedef struct tmr {
    struct tmr* next;      // 队列链接指针
    ustime_t deadline;     // 绝对截止时间（微秒）
    tmrcb_t callback;      // 到期回调函数
    void* ctx;             // 用户上下文数据
} tmr_t;
```

#### 1.3 关键算法
- **插入算法**: O(n) 复杂度的有序插入，适合少量定时器场景
- **处理算法**: 循环处理到期定时器，支持连续触发
- **精度优化**: 使用 `ATTR_FASTCODE` 标记的高性能处理函数

#### 1.4 API 接口
- `rt_iniTimer()`: 初始化定时器结构
- `rt_setTimer()`: 设置定时器截止时间
- `rt_clrTimer()`: 清除活动定时器
- `rt_processTimerQ()`: 处理定时器队列（主循环调用）
- `rt_yieldTo()`: CPU 让出机制

### 2. 时间管理系统

#### 2.1 多时间域支持
- **系统时间**: 单调递增的启动时间（rt_getTime）
- **UTC 时间**: 世界标准时间（rt_getUTC）
- **本地时间**: 日期时间结构化表示（rt_datetime）

#### 2.2 时间转换机制
```c
// UTC 偏移管理
ustime_t rt_utcOffset;      // UTC - 系统时间的偏移量
ustime_t rt_utcOffset_ts;   // 偏移量设定时的系统时间戳

// 转换公式
UTC时间 = 系统时间 + UTC偏移量
```

#### 2.3 复杂日期算法
- **闰年处理**: 格里高利历闰年规则（4年一闰，百年不闰，400年又闰）
- **月份计算**: 基于每月天数表的精确计算
- **时间分解**: 微秒 → 秒 → 分 → 时 → 日 → 月 → 年的逐级提取

### 3. 内存管理系统

#### 3.1 安全分配机制
- **失败处理**: 分配失败时自动调用 `rt_fatal()` 终止程序
- **零初始化**: 可选的内存清零功能
- **调试跟踪**: DEBUG 模式下的分配/释放位置记录

#### 3.2 字符串处理工具
- `rt_strdup()`: 字符串复制
- `rt_strdupn()`: 限长字符串复制
- `rt_strdupq()`: 带引号的字符串复制（JSON 格式）

#### 3.3 动态缓冲区
- `dbuf_dup()`: 缓冲区深拷贝
- `dbuf_free()`: 安全的缓冲区释放

### 4. 数据处理工具

#### 4.1 字节序转换
- `rt_rlsbf2/4/8()`: 小端序读取（Little-Endian）
- `rt_rmsbf2()`: 大端序读取（Big-Endian）
- 支持跨平台的字节序处理

#### 4.2 CRC-32 校验
```c
// 标准 CRC-32 多项式: 0x04C11DB7
static const uint32_t crc_table[256];  // 预计算查找表

// 高效计算算法
u4_t rt_crc32(u4_t crc, const void* buf, int size) {
    crc = crc ^ ~0U;                    // 初始化
    while(size-- > 0)
        crc = crc_table[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
    return crc ^ ~0U;                   // 最终化
}
```

### 5. 配置解析器

#### 5.1 数值解析 (rt_readDec)
- **十进制**: 标准数字字符串 "123"
- **十六进制**: 0x 前缀格式 "0x1F"
- **位置更新**: 自动更新解析位置指针

#### 5.2 时间跨度解析 (rt_readSpan)
支持的时间单位：
- `d`: 天 (24*3600 秒)
- `h`: 小时 (3600 秒)
- `m`: 分钟 (60 秒)
- `ms`: 毫秒
- `s`: 秒

示例: "1h30m" → 5400 秒

#### 5.3 数据大小解析 (rt_readSize)
支持的大小单位：
- **十进制**: K/M/G (1000 进制)
- **二进制**: Kb/Mb/Gb (1024 进制)

示例: "1.5Mb" → 1,572,864 字节

#### 5.4 EUI 地址解析 (rt_readEui)
支持多种 EUI 格式：
- **标准格式**: "001122334455AABB"
- **短横线分隔**: "00-11-22-33-44-55-AA-BB"
- **冒号分隔**: "00:11:22:33:44:55:AA:BB"
- **ID6 格式**: IPv6 风格压缩 "1::2", "::AABB", "1122::"

### 6. 系统特性管理

#### 6.1 特性注册机制
- **动态扩展**: 自动扩展特性缓冲区
- **重复检测**: 防止重复添加相同特性
- **空格分隔**: 特性间使用空格分隔

#### 6.2 应用场景
- 系统能力声明（支持的协议版本、功能特性）
- 客户端兼容性检查
- 调试信息输出

## 性能特征

### 1. 定时器系统性能
- **插入复杂度**: O(n)，n 为活动定时器数量
- **处理复杂度**: O(1) 每个到期定时器
- **内存开销**: 每个定时器 32 字节（64位系统）
- **精度**: 微秒级，取决于系统时钟分辨率

### 2. 解析器性能
- **数值解析**: ~10M 数字/秒
- **字符串解析**: ~5M 字符/秒
- **EUI 解析**: ~1M 地址/秒
- **CRC 计算**: ~500MB/秒

### 3. 内存管理效率
- **分配开销**: 标准 malloc + 失败检查
- **调试开销**: DEBUG 模式额外 ~10% 开销
- **碎片控制**: 依赖系统 malloc 实现

## 错误处理策略

### 1. 致命错误处理
```c
void rt_fatal(const char* fmt, ...) {
    log_vmsg(CRITICAL, fmt, ap);    // 记录关键错误
    sys_fatal(0);                   // 终止程序
}
```

### 2. 可恢复错误
- **解析失败**: 返回 -1 或 0
- **空指针检查**: 安全返回默认值
- **范围检查**: 参数有效性验证

### 3. 断言机制
- 关键不变式检查
- 调试模式下的额外验证
- 生产环境下的性能优化

## 平台适配

### 1. 系统抽象层依赖
- `sys_time()`: 单调时钟
- `sys_usleep()`: 微秒延时
- `sys_eui()`: 设备标识
- `sys_utc()`: UTC 时间
- `sys_fatal()`: 程序终止

### 2. 编译时配置
- `CFG_timerfd`: Linux timerfd 支持
- `ATTR_FASTCODE`: 高性能代码标记
- 调试宏控制

### 3. 移植考虑
- 字节序处理
- 时间精度差异
- 内存对齐要求

## 最佳实践

### 1. 定时器使用
```c
tmr_t my_timer;
rt_iniTimer(&my_timer, my_callback);
rt_setTimer(&my_timer, rt_getTime() + rt_seconds(5));  // 5秒后触发
```

### 2. 内存管理
```c
char* buffer = rt_malloc(1024);    // 安全分配
// 使用 buffer...
rt_free(buffer);                   // 及时释放
```

### 3. 配置解析
```c
str_t config = "1h30m";
str_t* p = &config;
ustime_t timeout = rt_readSpan(&p, rt_seconds(1));  // 默认单位：秒
```

### 4. 错误处理
```c
if (result < 0) {
    LOG(ERROR, "解析失败: %s", input);
    return ERROR_PARSE_FAILED;
}
```

## 调试和监控

### 1. 调试支持
- 内存分配跟踪
- 定时器状态检查
- 详细错误日志

### 2. 性能监控
- 定时器队列长度
- 内存使用统计
- 解析性能计数

### 3. 故障诊断
- 定时器回调异常
- 内存泄漏检测
- 解析格式错误

运行时系统为 BasicStation 提供了稳定可靠的基础设施，其高精度定时器、安全内存管理和灵活的数据解析能力是整个系统正常运行的基石。 