# RAL主从进程架构技术详解

## 概述

RAL主从进程架构是BasicStation中用于管理多个LoRa网关芯片的高级架构设计。该架构将硬件控制和业务逻辑分离，通过多进程协作实现高可用性、故障隔离和性能优化。

### 设计目标
- **硬件隔离**: 每个从进程独立控制一个SX130X芯片，避免硬件访问冲突
- **故障恢复**: 单个芯片故障不影响整体系统运行，支持自动重启恢复
- **性能优化**: 专一化处理提升硬件操作效率，降低延迟
- **扩展性**: 支持动态增减芯片数量，灵活适应不同硬件配置

## 核心架构

### 主进程(ral_master.c)
主进程作为整个RAL系统的协调中心，负责：

#### 进程管理
- **从进程生命周期管理**: 启动、监控、重启、停止从进程
- **配置分发**: 解析JSON配置并分配给各从进程
- **状态监控**: 定期检查从进程健康状态，实现故障检测

#### 通信协调
- **管道通信**: 通过双向管道与从进程进行进程间通信
- **异步IO**: 使用事件驱动模型处理多个从进程的并发通信
- **命令分发**: 将上层RAL请求转发给对应的从进程

#### 时间同步
- **同步协调**: 协调各从进程的时间同步过程
- **精度管理**: 根据同步质量调整同步间隔
- **统一时间基准**: 维护全局一致的时间参考

### 从进程(ral_slave.c)
每个从进程专门控制一个SX130X芯片，负责：

#### 硬件控制
- **直接硬件访问**: 通过libloragw直接控制SX130X芯片
- **数据包处理**: 处理LoRa数据包的发送和接收
- **硬件状态管理**: 监控和报告硬件状态

#### 命令执行
- **配置执行**: 根据主进程指令配置硬件参数
- **发送处理**: 执行数据包发送操作，支持信标和数据模式
- **接收轮询**: 定期检查硬件接收缓冲区

#### 时间同步
- **本地测量**: 执行高精度时间同步测量
- **PPS支持**: 仅从进程0支持GPS PPS信号同步
- **时间报告**: 定期向主进程报告时间同步状态

## 进程间通信协议

### 通信机制
```c
// 管道通信架构
主进程 <---> 双向管道 <---> 从进程
  |                          |
下行管道(命令)              上行管道(响应/数据)
```

### 命令类型
1. **RAL_CMD_CONFIG**: 配置命令，包含JSON配置和信道分配
2. **RAL_CMD_TX**: 发送命令，支持CCA和无CCA模式
3. **RAL_CMD_TXSTATUS**: 发送状态查询
4. **RAL_CMD_TXABORT**: 发送中止命令
5. **RAL_CMD_TIMESYNC**: 时间同步请求
6. **RAL_CMD_RX**: 接收数据上报(从进程主动发送)
7. **RAL_CMD_STOP**: 停止命令

### 消息格式
```c
struct ral_header {
    sL_t rctx;    // 请求上下文(从进程索引)
    u1_t cmd;     // 命令类型
};

struct ral_tx_req {
    sL_t  rctx;   // 请求上下文
    u1_t  cmd;    // 命令类型
    u1_t  txlen;  // 数据长度
    s2_t  txpow;  // 发送功率
    rps_t rps;    // RPS参数
    u1_t  addcrc; // 是否添加CRC
    u4_t  freq;   // 发送频率
    sL_t  xtime;  // 发送时间戳
    u1_t  txdata[MAX_TXFRAME_LEN]; // 发送数据
};
```

## 关键技术特性

### 1. 故障检测与恢复

#### 检测机制
- **定期检测**: 500ms间隔检查从进程状态
- **进程状态**: 使用waitpid(WNOHANG)非阻塞检查
- **通信检测**: 管道EOF检测主/从进程异常

#### 重启策略
```c
// 渐进式信号升级
if (killCnt <= 2) {
    kill(pid, SIGTERM);  // 温和终止
} else {
    kill(pid, SIGKILL);  // 强制杀死
}
```

#### 恢复流程
1. **清理资源**: 关闭旧管道、清除定时器
2. **创建新进程**: fork + execv启动新从进程
3. **重新配置**: 完整的配置重传和硬件初始化
4. **状态同步**: 重建时间同步和监控机制

### 2. 配置管理

#### 配置解析
```c
// JSON配置解析和分发
ujdec_t D;
uj_iniDecoder(&D, json, jsonlen);
while ((slaveIdx = uj_nextSlot(&D)) >= 0) {
    slaves[slaveIdx].sx1301confJson = dbuf_dup(uj_skipValue(&D));
}
```

#### 信道分配
- **回调机制**: 通过slave_challoc_cb分配信道
- **配置复制**: 支持配置复制实现天线分集
- **动态分配**: 根据硬件数量动态调整配置

### 3. 时间同步架构

#### 同步层次
```
GPS PPS -> 从进程0 -> 主进程 -> 其他从进程
    |         |         |         |
   硬件     本地测量   协调管理   时间校准
```

#### 质量控制
- **质量评估**: 基于测量精度确定同步质量
- **自适应间隔**: 根据质量调整同步频率
- **故障降级**: 质量差时增加同步频率

### 4. 天线分集支持

#### 分集策略
```c
// 天线类型检查
if (slaves[txunit].antennaType == SX130X_ANT_OMNI) {
    // 查找其他全向天线作为备用
    for (int sidx = 0; sidx < n_slaves; sidx++) {
        if (sidx != txunit && 
            slaves[sidx].antennaType == SX130X_ANT_OMNI) {
            backup_mask |= 1 << sidx;
        }
    }
}
```

#### 负载均衡
- **轮询分配**: 循环使用可用天线
- **故障切换**: 主天线故障时自动切换备用
- **性能优化**: 根据信号质量选择最佳天线

## 性能特点

### 并发处理
- **异步IO**: 事件驱动的非阻塞通信
- **并行执行**: 多从进程并行处理硬件操作
- **管道缓冲**: PIPE_BUF大小的原子写入保证

### 资源管理
- **内存隔离**: 各进程独立内存空间
- **文件描述符**: 精确管理避免泄漏
- **定时器**: 高精度微秒级定时器支持

### 延迟优化
- **直接硬件访问**: 从进程直接控制硬件，减少中间层
- **预配置**: 启动时完成硬件配置，运行时快速响应
- **批量处理**: 接收数据包批量处理提升效率

## 常见问题与解决方案

### 1. 从进程频繁重启
**现象**: 从进程不断死亡重启，重启计数快速增长
**原因**: 
- 硬件故障或配置错误
- SPI总线冲突
- 权限不足

**解决方案**:
```c
// 增加重启保护
if (++slave->restartCnt > 4) {
    rt_fatal("Slave %d restarted %d times without successful interaction",
             slaveIdx, slave->restartCnt);
}
```

### 2. 管道通信阻塞
**现象**: 管道写入失败，出现EAGAIN错误
**原因**: 主进程处理速度慢，管道缓冲区满

**解决方案**:
```c
// 重试机制和消息丢弃
if (errno == EAGAIN) {
    if (++retries > 5) {
        LOG(MOD_RAL|ERROR, "Pipe full - dropping message");
        return; // 丢弃消息而不是阻塞
    }
    rt_usleep(rt_millis(1));
}
```

### 3. 时间同步失效
**现象**: 时间同步质量下降，影响发送精度
**原因**: 
- GPS信号不稳定
- 硬件时钟漂移
- 系统负载过高

**解决方案**:
- **质量监控**: 持续监控同步质量
- **自适应频率**: 质量差时增加同步频率
- **降级处理**: 必要时切换到本地时钟

### 4. 配置同步失败
**现象**: 从进程配置失败，硬件无法启动
**原因**: 
- JSON配置格式错误
- 硬件规格不匹配
- LBT配置超时

**解决方案**:
```c
// 多阶段配置验证
if ((status = !sx130xconf_parse_setup(&sx1301conf, ...)) ||
    (status = !sx130xconf_challoc(&sx1301conf, ...) << 1) ||
    (status = !sys_runRadioInit(sx1301conf.device) << 2) ||
    (status = !sx130xconf_start(&sx1301conf, ...) << 3)) {
    rt_fatal("Slave radio start up failed with status 0x%02x", status);
}
```

## 开发指南

### 添加新命令类型
1. **定义命令**: 在ralsub.h中添加新的RAL_CMD_XXX
2. **定义结构**: 创建对应的请求/响应结构体
3. **主进程处理**: 在ral_master.c中添加命令分发逻辑
4. **从进程处理**: 在ral_slave.c中添加命令处理逻辑

### 扩展硬件支持
1. **配置解析**: 扩展sx130xconf支持新硬件类型
2. **HAL适配**: 确保libloragw支持新芯片
3. **参数转换**: 更新RPS转换函数支持新参数
4. **测试验证**: 全面测试新硬件的各项功能

### 性能优化
1. **减少系统调用**: 批量处理减少上下文切换
2. **内存对齐**: 结构体内存对齐优化访问效率
3. **缓存优化**: 合理使用缓存减少重复计算
4. **异步处理**: 最大化异步IO并发度

## 最佳实践

### 1. 错误处理
- **分级处理**: 区分致命错误和可恢复错误
- **详细日志**: 记录足够信息用于问题诊断
- **优雅降级**: 部分功能失效时维持基本服务

### 2. 资源管理
- **及时清理**: 进程退出时清理所有资源
- **引用计数**: 避免资源泄漏和重复释放
- **边界检查**: 严格检查数组和缓冲区边界

### 3. 并发安全
- **原子操作**: 使用管道原子写入特性
- **状态同步**: 正确维护进程间状态一致性
- **死锁避免**: 避免循环等待和资源竞争

### 4. 可维护性
- **模块化设计**: 清晰的功能模块划分
- **统一接口**: 一致的API设计和错误处理
- **文档完善**: 详细的代码注释和设计文档

通过以上技术架构和实现策略，RAL主从进程架构为BasicStation提供了高可靠、高性能、易扩展的多芯片管理能力，是LoRa网关系统的重要技术基础。 